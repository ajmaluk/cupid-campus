-- Enable Row Level Security
-- (This is idempotent safe)
alter default privileges in schema public grant all on tables to postgres, anon, authenticated, service_role;

-- Enums for better data integrity (Handled with Exception block for updates)
do $$ 
begin
  if not exists (select 1 from pg_type where typname = 'gender_enum') then
    create type public.gender_enum as enum ('Male', 'Female', 'Non-binary', 'Other');
  end if;
end $$;

do $$ 
begin
  if not exists (select 1 from pg_type where typname = 'interest_gender_enum') then
    create type public.interest_gender_enum as enum ('Male', 'Female', 'Everyone');
  end if;
end $$;

do $$ 
begin
  if not exists (select 1 from pg_type where typname = 'rec_type_enum') then
    create type public.rec_type_enum as enum ('standard', 'soulmate', 'friend');
  end if;
end $$;

-- Profiles Table
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  username text unique, -- Added username
  name text,
  dob date, -- Added DOB
  age integer check (age >= 18),
  gender public.gender_enum,
  interested_in public.interest_gender_enum,
  department text, -- e.g., 'MCA', 'BTech', 'MTech'
  major text, -- e.g., 'Computer Science', 'Civil Engineering'
  course text, -- Display string e.g. "B.Tech - CS"
  year text, -- e.g., 'First Year', 'Second Year'
  bio text,
  interests text[], -- Array of strings
  photos jsonb, -- JSON array of photo objects {url, id, is_primary}
  primary_photo text,
  vibe_score jsonb, -- Stored computed vibe vector/score
  is_verified boolean default false, -- Email verification status (synced from auth)
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add new columns if they don't exist
do $$ 
begin
  if not exists (select 1 from information_schema.columns where table_name = 'profiles' and column_name = 'course') then
    alter table public.profiles add column course text;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'profiles' and column_name = 'username') then
    alter table public.profiles add column username text unique;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'profiles' and column_name = 'dob') then
    alter table public.profiles add column dob date;
  end if;
end $$;

-- Indexes for performance (Idempotent)
create index if not exists profiles_gender_idx on public.profiles(gender);
create index if not exists profiles_interested_in_idx on public.profiles(interested_in);
create index if not exists profiles_department_idx on public.profiles(department);
create index if not exists profiles_username_idx on public.profiles(username);

alter table public.profiles enable row level security;

-- Drop existing policies to ensure updates apply
drop policy if exists "Public profiles are viewable by everyone" on public.profiles;
drop policy if exists "Profiles are viewable by authenticated users" on public.profiles;
create policy "Profiles are viewable by authenticated users"
  on public.profiles for select
  using ( auth.role() = 'authenticated' );

drop policy if exists "Users can insert their own profile" on public.profiles;
create policy "Users can insert their own profile"
  on public.profiles for insert
  with check ( auth.uid() = id );

drop policy if exists "Users can update their own profile" on public.profiles;
create policy "Users can update their own profile"
  on public.profiles for update
  using ( auth.uid() = id );

-- Swipes Table
create table if not exists public.swipes (
  id bigint generated by default as identity primary key,
  swiper_id uuid references public.profiles(id) not null,
  swiped_id uuid references public.profiles(id) not null,
  liked boolean not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(swiper_id, swiped_id)
);

create index if not exists swipes_swiper_id_idx on public.swipes(swiper_id);
create index if not exists swipes_swiped_id_idx on public.swipes(swiped_id);

alter table public.swipes enable row level security;

drop policy if exists "Users can see their own swipes" on public.swipes;
create policy "Users can see their own swipes"
  on public.swipes for select
  using ( auth.uid() = swiper_id );

drop policy if exists "Users can insert their own swipes" on public.swipes;
create policy "Users can insert their own swipes"
  on public.swipes for insert
  with check ( auth.uid() = swiper_id );

-- Matches Table
create table if not exists public.matches (
  id bigint generated by default as identity primary key,
  user1 uuid references public.profiles(id) not null,
  user2 uuid references public.profiles(id) not null,
  compatibility_score float,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user1, user2)
);

create index if not exists matches_user1_idx on public.matches(user1);
create index if not exists matches_user2_idx on public.matches(user2);

alter table public.matches enable row level security;

drop policy if exists "Users can see their matches" on public.matches;
create policy "Users can see their matches"
  on public.matches for select
  using ( auth.uid() = user1 or auth.uid() = user2 );

-- Chats/Messages Table (Real-time 1:1)
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  match_id bigint references public.matches(id) not null,
  sender_id uuid references public.profiles(id) not null,
  content text not null,
  is_read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index if not exists messages_match_id_idx on public.messages(match_id);
create index if not exists messages_sender_id_idx on public.messages(sender_id);

alter table public.messages enable row level security;

drop policy if exists "Users can see messages in their matches" on public.messages;
create policy "Users can see messages in their matches"
  on public.messages for select
  using (
    exists (
      select 1 from public.matches m
      where m.id = messages.match_id
      and (m.user1 = auth.uid() or m.user2 = auth.uid())
    )
  );

drop policy if exists "Users can insert messages in their matches" on public.messages;
create policy "Users can insert messages in their matches"
  on public.messages for insert
  with check (
    auth.uid() = sender_id
    and exists (
      select 1 from public.matches m
      where m.id = match_id
      and (m.user1 = auth.uid() or m.user2 = auth.uid())
    )
  );

-- Admin Roles Table (Secure source of truth)
create table if not exists public.admins (
  id uuid references auth.users not null primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.admins enable row level security;

drop policy if exists "Admins can see themselves" on public.admins;
create policy "Admins can see themselves"
  on public.admins for select
  using ( auth.uid() = id );

-- Admin Recommendations Table
create table if not exists public.admin_recommendations (
  id bigint generated by default as identity primary key,
  admin_id uuid references auth.users not null,
  target_user_id uuid references public.profiles(id) not null,
  recommended_user_id uuid references public.profiles(id) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  type public.rec_type_enum default 'standard', -- Added type support
  unique(target_user_id, recommended_user_id)
);

-- Add 'type' column if it doesn't exist (Migration support)
do $$ 
begin
  if not exists (select 1 from information_schema.columns where table_name = 'admin_recommendations' and column_name = 'type') then
    alter table public.admin_recommendations add column type public.rec_type_enum default 'standard';
  end if;
end $$;

alter table public.admin_recommendations enable row level security;

drop policy if exists "Admins can manage recommendations" on public.admin_recommendations;
create policy "Admins can manage recommendations"
  on public.admin_recommendations for all
  using ( exists (select 1 from public.admins where id = auth.uid()) );

drop policy if exists "Users can see recommendations for them" on public.admin_recommendations;
create policy "Users can see recommendations for them"
  on public.admin_recommendations for select
  using ( auth.uid() = target_user_id );

-- Reports Table
create table if not exists public.reports (
  id bigint generated by default as identity primary key,
  reporter_id uuid references public.profiles(id) not null,
  reported_user_id uuid references public.profiles(id) not null,
  reason text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.reports enable row level security;

drop policy if exists "Users can create reports" on public.reports;
create policy "Users can create reports"
  on public.reports for insert
  with check ( auth.uid() = reporter_id );

-- Bans Table
create table if not exists public.bans (
  user_id uuid references public.profiles(id) primary key,
  reason text,
  banned_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.bans enable row level security;

drop policy if exists "Admins can view bans" on public.bans;
create policy "Admins can view bans"
  on public.bans for select
  using ( exists (select 1 from public.admins where id = auth.uid()) );

drop policy if exists "Admins can insert bans" on public.bans;
create policy "Admins can insert bans"
  on public.bans for insert
  with check ( exists (select 1 from public.admins where id = auth.uid()) );
 

-- Functions & Triggers

-- 1. Secure Signup: Enforce @cet.ac.in domain
create or replace function public.handle_new_user()
returns trigger as $$
begin
  -- Enforce Domain Restriction
  if new.email not like '%@cet.ac.in' then
    raise exception 'Registration restricted to College of Engineering Trivandrum (@cet.ac.in) students only.';
  end if;

  insert into public.profiles (id, name, created_at, updated_at)
  values (new.id, new.raw_user_meta_data->>'full_name', now(), now())
  on conflict (id) do nothing; -- Prevent error if profile exists
  
  return new;
end;
$$ language plpgsql security definer;

-- Trigger for new user
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 2. Match Logic: Check for mutual likes
create or replace function public.check_match()
returns trigger as $$
declare
  other_liked boolean;
begin
  -- If the swipe is a LIKE (true)
  if new.liked = true then
    -- Check if the other user already liked the current swiper
    select liked into other_liked
    from public.swipes
    where swiper_id = new.swiped_id
    and swiped_id = new.swiper_id;

    if other_liked = true then
      -- It's a match! Insert into matches table
      insert into public.matches (user1, user2)
      values (least(new.swiper_id, new.swiped_id), greatest(new.swiper_id, new.swiped_id))
      on conflict (user1, user2) do nothing; -- Prevent duplicate matches
    end if;
  end if;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_swipe_created on public.swipes;
create trigger on_swipe_created
  after insert on public.swipes
  for each row execute procedure public.check_match();
